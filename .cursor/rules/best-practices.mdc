---
alwaysApply: true
---

# Next.js + React + TypeScript + TailwindCSS + Jest Best Practices

## Project Overview

This is a Next.js 15 project using React 19, TypeScript, TailwindCSS 4, and Jest for testing. Follow these rules to maintain high code quality and consistency.

## General Principles

### SOLID Principles

- **Single Responsibility**: Each component/function should have one clear purpose
- **Open/Closed**: Components should be open for extension, closed for modification
- **Liskov Substitution**: Derived components should be substitutable for their base types
- **Interface Segregation**: Create small, focused interfaces rather than large ones
- **Dependency Inversion**: Depend on abstractions, not concretions

### DRY (Don't Repeat Yourself)

- Extract reusable logic into custom hooks
- Create shared components for common UI patterns
- Use TypeScript interfaces/types for shared data structures
- Implement utility functions for repeated operations

## File Structure & Organization

### Folder Structure

```
src/
├── app/ # Next.js App Router
│ ├── (auth)/ # Route groups
│ ├── api/ # API routes
│ └── globals.css # Global styles
├── components/ # Reusable UI components
│ ├── ui/ # Base UI components (Button, Input, etc.)
│ ├── forms/ # Form-specific componentsj
│ └── layout/ # Layout components (Header, Footer, etc.)
├── hooks/ # Custom React hooks
├── lib/ # Utility functions and configurations
├── types/ # TypeScript type definitions
├── constants/ # Application constants
├── utils/ # Helper functions
└── tests/ # Test files
```

### File Naming Conventions

- **Components**: PascalCase (`UserProfile.tsx`)
- **Hooks**: camelCase starting with 'use' (`useUserData.ts`)
- **Utils/Libs**: camelCase (`formatDate.ts`)
- **Types**: PascalCase (`UserTypes.ts`)
- **Constants**: SCREAMING_SNAKE_CASE in camelCase files (`apiEndpoints.ts`)

## React & Component Best Practices

### Component Structure

- Always use functional components with TypeScript
- Use React.FC sparingly, prefer explicit return types
- Export components as default when they're the main export
- Use named exports for utility functions and types

```typescript
interface UserCardProps {
  user: User;
  onEdit?: (user: User) => void;
  className?: string;
}

export default function UserCard({ user, onEdit, className }: UserCardProps) {
  return (
    <div className={cn("rounded-lg border p-4", className)}>
      {/* component content */}
    </div>
  );
}
```

### Props & TypeScript

- Always define explicit prop interfaces
- Use optional props (`?`) appropriately
- Prefer `interface` over `type` for component props
- Use generic types for reusable components
- Avoid `any` - use `unknown` or specific types

### State Management

- Use `useState` for local component state
- Use `useReducer` for complex state logic
- Extract state logic to custom hooks when reused
- Keep state as close to where it's used as possible

### Custom Hooks

- Start with 'use' prefix
- Return objects for multiple values, not arrays (unless order matters)
- Include proper TypeScript return types
- Handle loading and error states consistently

```typescript
interface UseUserDataReturn {
  user: User | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

export function useUserData(userId: string): UseUserDataReturn {
  // hook implementation
}
```

## Next.js Specific Rules

### App Router (Next.js 15)

- Use Server Components by default
- Add 'use client' directive only when necessary
- Prefer server-side data fetching when possible
- Use proper loading.tsx and error.tsx files
- Implement proper metadata for SEO

### API Routes

- Use proper HTTP status codes
- Implement error handling consistently
- Validate input data with TypeScript/Zod
- Use proper TypeScript types for request/response

### Performance

- Use `next/image` for all images
- Implement proper lazy loading
- Use `next/dynamic` for code splitting
- Minimize client-side JavaScript

## TailwindCSS Guidelines

### Class Organization

- Use `cn()` utility for conditional classes (install `clsx` and `tailwind-merge`)
- Order classes: layout → spacing → sizing → colors → typography → effects
- Extract common class combinations into CSS components or utilities
- Use semantic class names for complex layouts

```typescript
// Good
const buttonVariants = {
  primary: "bg-blue-600 hover:bg-blue-700 text-white",
  secondary: "bg-gray-200 hover:bg-gray-300 text-gray-900",
};

// Usage
<button className={cn("px-4 py-2 rounded-md font-medium", buttonVariants.primary, className)}>
```

### Responsive Design

- Mobile-first approach (default styles for mobile)
- Use Tailwind's responsive prefixes (`sm:`, `md:`, `lg:`, `xl:`, `2xl:`)
- Test on multiple screen sizes

## Fabric.js V6 Canvas Library

### Overview

Fabric.js is a powerful HTML5 canvas library that provides an interactive object model for canvas elements. It supports shapes, controls, brushes, and advanced drawing capabilities.

### Installation & Setup

```bash
npm install fabric
# or
yarn add fabric
```

### Basic Canvas Component Structure

Always use the 'use client' directive for Fabric.js components as they require browser APIs:

```typescript
"use client";

import React, { useEffect, useRef, useCallback } from "react";
import * as fabric from "fabric";

interface FabricJSCanvasProps {
  width?: number;
  height?: number;
  className?: string;
  onCanvasReady?: (canvas: fabric.Canvas) => void;
}

export default function FabricJSCanvas({
  width = 800,
  height = 600,
  className,
  onCanvasReady,
}: FabricJSCanvasProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const fabricCanvasRef = useRef<fabric.Canvas | null>(null);

  useEffect(() => {
    if (!canvasRef.current) return;

    const canvas = new fabric.Canvas(canvasRef.current, {
      width,
      height,
      backgroundColor: "#ffffff",
      selection: true,
      preserveObjectStacking: true,
    });

    fabricCanvasRef.current = canvas;

    if (onCanvasReady) {
      onCanvasReady(canvas);
    }

    return () => {
      canvas.dispose();
      fabricCanvasRef.current = null;
    };
  }, [width, height, onCanvasReady]);

  return (
    <canvas
      ref={canvasRef}
      className={cn("border border-gray-300 rounded-lg", className)}
    />
  );
}
```

### Canvas Context Management

Create a custom hook to manage canvas context across components:

```typescript
interface UseCanvasContextReturn {
  canvas: fabric.Canvas | null;
  setCanvas: (canvas: fabric.Canvas | null) => void;
  isReady: boolean;
}

export function useCanvasContext(): UseCanvasContextReturn {
  const [canvas, setCanvas] = useState<fabric.Canvas | null>(null);
  const [isReady, setIsReady] = useState(false);

  useEffect(() => {
    setIsReady(!!canvas);
  }, [canvas]);

  return { canvas, setCanvas, isReady };
}
```

### Working with Shapes

#### Basic Shapes

```typescript
// Rectangle
const rect = new fabric.Rect({
  left: 100,
  top: 100,
  width: 100,
  height: 100,
  fill: "red",
  stroke: "black",
  strokeWidth: 2,
});

// Circle
const circle = new fabric.Circle({
  left: 200,
  top: 200,
  radius: 50,
  fill: "blue",
  stroke: "darkblue",
  strokeWidth: 3,
});

// Text
const text = new fabric.Text("Hello Fabric.js", {
  left: 150,
  top: 300,
  fontSize: 24,
  fill: "green",
  fontFamily: "Arial",
});

canvas.add(rect, circle, text);
canvas.renderAll();
```

#### Shape Manipulation

```typescript
// Select and modify shapes
rect.set({
  fill: "yellow",
  angle: 45,
  scaleX: 1.5,
  scaleY: 1.5,
});

// Group objects
const group = new fabric.Group([rect, circle], {
  left: 100,
  top: 100,
});

canvas.add(group);
canvas.setActiveObject(group);
```

### Controls and Interaction

#### Custom Controls

```typescript
// Add custom control points
fabric.Object.prototype.controls.deleteControl = new fabric.Control({
  x: -0.5,
  y: -0.5,
  offsetX: -10,
  offsetY: -10,
  cursorStyle: "pointer",
  actionHandler: fabric.controlsUtils.deleteObject,
  render: function (ctx, left, top, styleOverride, fabricObject) {
    const size = 20;
    ctx.save();
    ctx.translate(left, top);
    ctx.rect(-size / 2, -size / 2, size, size);
    ctx.fillStyle = "red";
    ctx.fill();
    ctx.restore();
  },
});
```

#### Event Handling

```typescript
// Mouse events
canvas.on("mouse:down", (options) => {
  if (options.target) {
    console.log("Selected object:", options.target);
  }
});

canvas.on("object:modified", (options) => {
  console.log("Object modified:", options.target);
});

canvas.on("selection:created", (options) => {
  console.log("Selection created:", options.selected);
});
```

### Brushes and Drawing

#### Free Drawing

```typescript
// Enable free drawing
canvas.isDrawingMode = true;
canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
canvas.freeDrawingBrush.color = "#000000";
canvas.freeDrawingBrush.width = 5;

// Custom brush
class CustomBrush extends fabric.PencilBrush {
  constructor(canvas: fabric.Canvas) {
    super(canvas);
    this.color = "#ff0000";
    this.width = 10;
  }

  _render(ctx: CanvasRenderingContext2D) {
    ctx.strokeStyle = this.color;
    ctx.lineWidth = this.width;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
  }
}

canvas.freeDrawingBrush = new CustomBrush(canvas);
```

#### Pattern Brushes

```typescript
// Create pattern brush
const patternBrush = new fabric.PatternBrush(canvas);
patternBrush.source = new fabric.Rect({
  width: 20,
  height: 20,
  fill: "red",
});

canvas.freeDrawingBrush = patternBrush;
```

### Performance Optimization

#### Object Pooling

```typescript
class ShapePool {
  private pool: fabric.Object[] = [];
  private maxSize: number;

  constructor(maxSize = 100) {
    this.maxSize = maxSize;
  }

  get(): fabric.Object | null {
    return this.pool.pop() || null;
  }

  return(obj: fabric.Object): void {
    if (this.pool.length < this.maxSize) {
      obj.set({ left: 0, top: 0, visible: false });
      this.pool.push(obj);
    }
  }
}
```

#### Canvas Rendering

```typescript
// Batch operations
canvas.renderOnAddRemove = false;
// ... perform multiple operations
canvas.renderAll();

// Use requestAnimationFrame for smooth animations
function animate() {
  // Update object properties
  requestAnimationFrame(animate);
}
```

### TypeScript Integration

#### Custom Type Definitions

```typescript
interface CustomShape extends fabric.Object {
  customProperty?: string;
  customMethod?: () => void;
}

interface CanvasOptions extends fabric.ICanvasOptions {
  customOption?: boolean;
}

// Extend fabric objects
declare module "fabric" {
  namespace fabric {
    interface Object {
      customProperty?: string;
    }
  }
}
```

### Testing Fabric.js Components

#### Mock Fabric.js in Tests

```typescript
// __mocks__/fabric.ts
export const Canvas = jest.fn().mockImplementation(() => ({
  add: jest.fn(),
  remove: jest.fn(),
  renderAll: jest.fn(),
  dispose: jest.fn(),
  on: jest.fn(),
  off: jest.fn(),
  setActiveObject: jest.fn(),
  getActiveObject: jest.fn(),
}));

export const Rect = jest.fn().mockImplementation(() => ({
  set: jest.fn(),
  toObject: jest.fn(),
}));

export const Circle = jest.fn().mockImplementation(() => ({
  set: jest.fn(),
  toObject: jest.fn(),
}));

export const Text = jest.fn().mockImplementation(() => ({
  set: jest.fn(),
  toObject: jest.fn(),
}));
```

#### Component Testing

```typescript
import { render, screen } from "@testing-library/react";
import FabricJSCanvas from "./FabricJSCanvas";

jest.mock("fabric");

describe("FabricJSCanvas", () => {
  it("should render canvas element", () => {
    render(<FabricJSCanvas />);
    expect(screen.getByRole("img")).toBeInTheDocument();
  });

  it("should initialize fabric canvas on mount", () => {
    const mockCanvas = {
      add: jest.fn(),
      renderAll: jest.fn(),
      dispose: jest.fn(),
    };

    (fabric.Canvas as jest.Mock).mockImplementation(() => mockCanvas);

    render(<FabricJSCanvas />);
    expect(fabric.Canvas).toHaveBeenCalled();
  });
});
```

### Best Practices

#### Memory Management

- Always dispose of canvas instances in useEffect cleanup
- Remove event listeners when components unmount
- Use object pooling for frequently created/destroyed objects
- Limit the number of objects on canvas for performance

#### State Management

- Keep canvas state in React state or context
- Use useCallback for event handlers to prevent unnecessary re-renders
- Implement undo/redo functionality using command pattern
- Save canvas state as JSON for persistence

#### Error Handling

```typescript
try {
  const canvas = new fabric.Canvas(canvasRef.current);
  // ... canvas operations
} catch (error) {
  console.error("Failed to initialize canvas:", error);
  // Handle gracefully - show fallback UI
}
```

## Accessibility Standards

### Semantic HTML

- Use proper HTML5 semantic elements (`header`, `nav`, `main`, `section`, `article`, `aside`, `footer`)
- Use headings hierarchically (`h1` → `h2` → `h3`)
- Provide alt text for images
- Use proper form labels and ARIA attributes

### ARIA and Keyboard Navigation

- Implement proper focus management
- Use ARIA labels, descriptions, and roles where needed
- Ensure all interactive elements are keyboard accessible
- Maintain logical tab order

```tsx
// Good
<button
  aria-label="Close dialog"
  aria-describedby="dialog-description"
  onClick={onClose}
  className="..."
>
  <X className="h-4 w-4" />
</button>
```

## Testing with Jest

### Test Structure

- Follow AAA pattern: Arrange, Act, Assert
- Use descriptive test names that explain the behavior
- Group related tests with `describe` blocks
- Test user interactions, not implementation details

### Component Testing

- Use React Testing Library
- Test from user's perspective
- Mock external dependencies
- Test error states and edge cases

```typescript
describe("UserCard", () => {
  it("should display user information correctly", () => {
    const mockUser = { id: "1", name: "John Doe", email: "john@example.com" };
    render(<UserCard user={mockUser} />);

    expect(screen.getByText("John Doe")).toBeInTheDocument();
    expect(screen.getByText("john@example.com")).toBeInTheDocument();
  });
});
```

## Code Quality & Standards

### Error Handling

- Use proper error boundaries for React components
- Implement consistent error handling in API routes
- Provide meaningful error messages to users
- Log errors appropriately for debugging

### Performance Optimization

- Use React.memo() for expensive components
- Implement proper key props for lists
- Avoid unnecessary re-renders
- Use useCallback and useMemo judiciously

### Code Style

- Use meaningful variable and function names
- Keep functions small and focused
- Add JSDoc comments for complex logic
- Use TypeScript strict mode
- Follow consistent import ordering:
  1. React imports
  2. Third-party libraries
  3. Internal components/hooks
  4. Relative imports
  5. Type-only imports last

```typescript
import React from "react";
import { NextPage } from "next";
import { Button } from "@/components/ui/Button";
import { useUserData } from "../hooks/useUserData";
import type { User } from "@/types/User";
```

### Preventing Unused Imports

- Configure ESLint to detect and warn about unused imports
- Use TypeScript's `noUnusedLocals` and `noUnusedParameters` compiler options
- Regularly clean up unused imports to keep code lean and improve build performance
- Use IDE features or extensions that automatically remove unused imports on save
- Avoid importing entire libraries when only specific functions are needed

```typescript
// Bad - importing entire library
import * as _ from "lodash";
const result = _.debounce(fn, 300);

// Good - import only what you need
import { debounce } from "lodash";
const result = debounce(fn, 300);

// Bad - unused import
import React, { useState, useEffect } from "react"; // useEffect is unused
import { Button } from "@/components/ui/Button"; // Button is unused

export default function MyComponent() {
  const [count, setCount] = useState(0);
  return <div>{count}</div>;
}

// Good - only necessary imports
import React, { useState } from "react";

export default function MyComponent() {
  const [count, setCount] = useState(0);
  return <div>{count}</div>;
}
```

#### ESLint Configuration

Add these rules to your ESLint config to catch unused imports:

```javascript
// eslint.config.mjs
export default [
  {
    rules: {
      "@typescript-eslint/no-unused-vars": [
        "error",
        {
          argsIgnorePattern: "^_",
          varsIgnorePattern: "^_",
          ignoreRestSiblings: true,
        },
      ],
      "no-unused-vars": "off", // Turn off base rule as it conflicts with TypeScript rule
      "import/no-unused-modules": ["error", { unusedExports: true }],
    },
  },
];
```

#### TypeScript Configuration

Enable these compiler options in `tsconfig.json`:

```json
{
  "compilerOptions": {
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true
  }
}
```

## Security Best Practices

- Sanitize user inputs
- Use environment variables for sensitive data
- Implement proper authentication/authorization
- Validate data on both client and server
- Use HTTPS in production

## Git & Development Workflow

- Write meaningful commit messages
- Keep commits atomic and focused
- Use feature branches
- Write tests before pushing to main
- Update documentation when adding new features

## AI Assistant Instructions

When generating code:

1. Always follow these established patterns and conventions
2. Include proper TypeScript types and interfaces
3. Implement accessibility features by default
4. Add error handling and loading states
5. Include relevant tests when creating new components
6. Use the existing project structure and naming conventions
7. Prioritize performance and user experience
8. Follow the DRY principle and create reusable components
9. Add proper JSDoc comments for complex functions
10. Ensure responsive design with TailwindCSS
